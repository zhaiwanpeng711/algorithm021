

学习笔记

1. 数组

   问题在于增加、删除的时候 O(n)，获取元素非常快O（1）;

   查看ArrayList源码，实现方式从原copy到目标地址 System.arraycopy(data,index,data,index+1,size-index);

2. 链表

   一个 next 指针 单链表  ；头指针 用head 表示，尾指针用tail表示 ，表示双向链表；尾指针指向头指针像贪吃蛇一样为循环链表；java 实现LinkedList 为双向链表；

   问题查询元素，增加和删除为O(1);查询为O(n);

   有序普通的数组可以用二分查找

3. 跳表

   调表要求链表里的元素必须是有序的；

   如何提高链表线性查找的效率->空间换时间，添加到原始链表的多级索引；O(logn) 怎么算的？这个一直理解不了；

   LRU缓存机制，用DoubleList;

   Redis 使用的是SkipList;

4. 栈

   先进后出，添加删除皆为O(1),查询O（n）

5. 队列

   先进先出，添加删除皆为O(1),查询O（n）

   实战用双端队列Deque多，两端均可添加删除元素。

   熟悉Java Stack 和Queue的源码；

6. 优先队列

   插入O(1)，取出O(logn)按照元素的优先级取出；

   底层具体实现的数据结构较为多样的和复杂：heap、bst、treap

7. 双端队列

8. 实战题目解析：

   五毒神掌：读题和思考，5-10分钟没有思路就看题解，找个最好理解的，最优秀的背诵默写，直到熟练；

   1.移动零：  1.loop count zeros   2.开新数组 如果碰到0就往后放 3.直接在数组种进行index操作；

   2.盛水最多的容器： 1.枚举 left bar .right bar  (x-y)*height_diff

                                    2.两重遍历，记录最大的值
        
                                    3.双指针法，双端夹逼O(n)

   3.爬楼梯：1.可否暴力？ 2.基本情况如何解决？3.找最近重复子问题（先人肉，在找规律）

       4.三数之和：1.暴力两层循环  2.两重暴力+哈希表法  3. 排序后夹逼法
        
       linkedlist题没有复杂的算法，大部分需要多练熟悉怎样操作指针
        
       5.环形链表：1.暴力遍历链表 2.快慢指针
        
       6.有效的括号：用栈解决，如果一个东西拥有最近相关性（类似于圆葱一样），就用栈来解决；
        
       7.最小栈：两个栈 一个是正常的栈 一个是最小值的栈
        
                         遇到栈实现队列或者用队列实现栈 都是使用两个栈会队列 ，这是固定套路； 
        
        8.柱状图种最大的矩形：1.固定中间的一个棒，找到它的左右边界这种思想要学会；
        
                                                2.维护以这个栈，这个栈里的元素从小到大排序，自底向上；每次入栈检查是否大于栈底元素，大于就入栈否则就进行出战操作，计算面积；
        
        9.滑动窗口：所有滑动窗口问题都使用双端队列来解决；

​      4.实战总结

​      1.[删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

```
首先读题 --把所有方案列出来--没有思路直接五毒神掌
精选理解：
删除数组中的重复项，根本问题就是比较数组中哪些是相同的因为是有序的所以只要比较相邻的 >=2个数就可以，
因为老师讲过顺序的数据是可以使用双指针法这个思路的
那么这题就可以开辟两个指针,一个从头开始，一个比他大1个index，然后遍历这个数组进行判断，
如果不相等则 慢指针++，慢指针指向的及之前的要保证都是不相同的，如果相等则快指针循环一直往后循环查找不同的，找到了就把那个数的值和之前自己一开始的index数据赋值，然后当前慢指针和快指针 中间的这段差值空缺怎么办？肯定都是重复的！可以不用管，只要快指针到头了，证明这个有序数组全都跑了一遍，不一样的都提上去了剩下的都是一样的了，慢指针位置往后的数据都可以抛弃掉；

```

2. [合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/) 

```
首先通过读题理解，都是有序的链表，合并成一个新的有序的链表，其实要做的就是合并的时候哪个链表的最小，
因为最大不好判断，如果当前是最小又比另一个也小那肯定是最小了放在首位，如果要比另一个大不一定是最大因为另一链表后面还有n个元素，都要判断不合适，然后在判断小的那个链表的next指向的元素是不比刚才的那个小，如果不是则把新链表的元素的next指针指向刚才比较较小的元素，这样依次类推一直比较下去，直到next是空了，则证明没有后续元素了，当前的链表元素是整个新链表的尾巴；这样看来就可以用递归，因为有依次类推逻辑都一样；
```

3. [合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/) 

```
合并两个有序数组，通过题意得知，都是有序的，nums1的里面有足够大的数据可以存储两个数组的总和至少是nums1.length+nums2.length的长度，因为是有序的，还是从nums[1]头的开始遍历判断？这样nums1的数据就设计到临时存储，因为不让开辟新空间所以不可取，从最大的开始判断的话，如果最大则直接放在新数组的末尾了，分别判断然后长度需要相应的下移减少，新数组也需要减少因为每次都会确定一个最大的只从后往前放；哪个数组大那个数组就需要比较剩余数组中最大的那个数了，所以需要自减； 
直到有一个数组是空了则直接copy到新数组就可以了，nums2可以直接copy nums1还需要吗？nums1就不用动了本身就在当前数组中，只要维护好nums1的长度知道哪个已经比对完了，当新数组比对有nums1最开始已经有值的index的时候直接覆盖就好了，因为这值可能已经复制到别的位置了；nums2这种情况的话需要全员copy过去就可以；
```

4. [两数之和](https://leetcode-cn.com/problems/two-sum/) 

   ```
   自己第一次见这个题 就想到用两次循环，第一次循环用hash存储 target减去一个数，把这个减法的值直接设置成key，value为index,然后第二次循环直接去hash里看看能不能取到即可；但是看精选题解用的是一遍循环，这个优化是没有想到的；
   ```

5. [移动零](https://leetcode-cn.com/problems/move-zeroes/) 

```
一开始想到的是用一个临时变量存储0的位置，然后循环这个数组判断是不是是不是等于0，不等于则跳过，等于0则把index给这个变量，然后下次再碰到不等于0的直接把值copy过去；但是看到优选题解都是统计非0的个数，这就有点懵逼
class Solution {
    public void moveZeroes(int[] nums) {
      int j=0;
      for(int i=0;i<nums.length;i++){
           if(nums[i]!=0&&nums[j]==0){
               nums[j]=nums[i];
               nums[i]=0;
           }else{
               j=i;
           }
      }

    }
}
不知道思路哪里有问题，最后只能看官方题解了
```

6. [加一](https://leetcode-cn.com/problems/plus-one/) 

   ```
   给定的数组加一，就可能会存在进位的情况，这种情况需要怎么处理时关键！如果加完1 不能被10整除肯定不需要进位，直接返回即可，加完需要进位就麻烦了，需要依次判断每位是不是都需要进位，如果最后整个数组全部迭代完还需要进位的话，只能开辟新数组了，新数组比原数组大一位，其余全补0即可
   ```

   